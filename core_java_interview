Interview Questions : (Core java +spring)
1. What are the oop principle, where you used polymorphism in your project?
Ans:
Abstraction
Encapsulation
Polymorphism
Inheritance
Association
Aggregation
Composition
buyBack two created method for outside of france people and france perople 

2. Why we are injecting interface reference in spring framework why not direct implementation?
Ans:DI

3. Tell me Hash Map implementation 
Ans:
hashmap internally hashing technic ,hashmap retrive hashcode of key.hashcode,passing to indexFor method of hashmap and create bucket of
this key-value and put inside buket,if same hashcode find then used linkedlist and inside same bucket

4. Difference between Linked List and Array List
Ans:
1. Implementation :  ArrayList is the resizable array implementation of list interface , while LinkedList is the Doubly-linked list implementation of the list interface.


2. Performance  :  Performance of ArrayList and LinkedList depends on the type of operation

a. get(int index) or search operation :  ArrayList get(int index) operation runs in constant time i.e O(1)  while LinkedList get(int index) operation run time is O(n) .

The reason behind ArrayList being faster than LinkedList is that ArrayList uses index based system for its elements as it internally uses array data structure , on the other hand ,
LinkedList does not provide index based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.

b. insert() or add(Object) operation :  Insertions in LinkedList are generally fast as compare to ArrayList.

In LinkedList adding or insertion is O(1) operation . While in ArrayList, if array is full i.e worst case,  there is extra cost of  resizing array and copying elements to the new array , which makes runtime of add operation in ArrayList O(n) , otherwise it is O(1) .

c. remove(int) operation :  Remove operation in LinkedList is generally same as ArrayList i.e. O(n).
In LinkedList , there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1) .
The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as parameter . This method traverses the LinkedList until it found the Object and unlink it from the original list . Hence this method run time is O(n).

5. How to make a map as synchronized map 
Ans:
The Map is not synchornized (not thread-safe). Collections.synchronizedMap() method returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map.
6. What is the difference between Collections.synchronizedMap(m) and concurrent hash map 
concurrent hash map:lock only entry wise,Collections.synchronizedMap(m):luck entire map
7. Difference between forEach and iterator 
In for-each loop, we can’t modify collection, it will throw a ConcurrentModificationException on the other hand with iterator we can modify collection.
Modifying a collection simply means removing an element or changing content of an item stored in the collection. This occurs because for-each loop implicitly creates an iterator but it is not exposed to the user thus we can’t modify the items in the collections.

8. Can we instantiate interface if not then why?
NO we cant create an object of an Interface ,we use an Interface to hide the implementations from user.Interface contains only abstract methods and as abstract methods do not have a body (of implementation code) we can not create an object without constructor also .

Interface - a declaration of methods that are expected of a class. If the class declares they implement the interface, it must provide implementations for all the methods declared by the interface.

Abstract Class - a class that cannot be instantiated. Often it will include one or more methods that are also declared abstract and must be implemented by sub classes for the subclass to be concrete, and therefore able to be instantiated. Does not have to include abstract methods; the documentation may otherwise specify what is required of a valid concrete subclass.

Suppose even if it is permitted, what is the use. Calling the abstract method with object does not yield any purpose as no output.
9. Difference between classNotFoundException and NoClassDefError in which situation we will face this?
ClassNotFoundException is an exception that occurs when you try to load a class at run time using Class.forName() or loadClass() methods and mentioned classes are not found in the classpath. NoClassDefFoundError is an error that occurs when a particular class is present at compile time, but was missing at run time

10. WAP to find number of vowels present and there count from given input String 
package com.vowel.count;

public class VowelTest {

	public int vowelCount(String str) {
		int count = 0;
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == 'a' || str.charAt(i) == 'e' || str.charAt(i) == 'i' || str.charAt(i) == 'o'
					|| str.charAt(i) == 'u') {
				count++;
			}
		}
		return count;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		VowelTest obj = new VowelTest();
		int count = obj.vowelCount("kumar swain");
		System.out.println("count:"+count);
	}

}

11. What is serializable? If my business object not implement serializable is there any problem?
not transfer through obj
